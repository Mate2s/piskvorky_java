/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package app;

import java.awt.Graphics;

/**
 *
 * @author Matej
 */
public class Panel extends javax.swing.JPanel {

    private final int maxSize=400;
    private final int tickLine=40;
    private final int columnCount=maxSize/tickLine;
    public Choice [][]array=new Choice[columnCount][columnCount];
    /**
     * Creates new form Panel
     */
    
    public Panel() {
        initComponents();
    }
    
    @Override
    public void paint(Graphics g) {
        super.paint(g); //To change body of generated methods, choose Tools | Templates.
        for(int i=0;i<maxSize; i=i+tickLine)
        {
            g.drawLine(i, 0, i, maxSize);
            g.drawLine(0, i, maxSize, i);
            
        }
        for(int i=0;i<columnCount;i++)
            for(int j=0;j<columnCount;j++)
            {
                if(array[i][j]==Choice.CIRCLE)
                {
                    g.drawOval(i*tickLine, j*tickLine, tickLine, tickLine);
                }
                else if(array[i][j]==Choice.CROSS)
                {
                    g.drawLine(i*tickLine, j*tickLine, (i+1)*tickLine, (j+1)*tickLine);
                    g.drawLine((i+1)*tickLine, j*tickLine, i*tickLine, (j+1)*tickLine);
                }
            }
    
    }
    
    public int getTickLine() 
    {
        return tickLine;
    }
    public Choice getMove() 
    {
        return move;
    }

    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setMaximumSize(new java.awt.Dimension(400, 400));
        setMinimumSize(new java.awt.Dimension(400, 400));
        setPreferredSize(new java.awt.Dimension(400, 400));
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    private Choice move=Choice.CIRCLE;
    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
        
        int x=evt.getX()/tickLine;
        int y=evt.getY()/tickLine;
        
        if(array[x][y]==null)
        {
            if(move==Choice.CIRCLE)
            {
                array[x][y]=Choice.CIRCLE;
                move=Choice.CROSS;
            }else
            {
                array[x][y]=Choice.CROSS;
                move=Choice.CIRCLE;                              
            }
            checkIsFive();
        }
        
        repaint();
    }//GEN-LAST:event_formMouseClicked

    Choice checkIsFive()
    {
        for(int i=0;i<maxSize/tickLine;i++)
        {
            for(int j=0;j<maxSize/tickLine;j++)
            {               
                if(array[i][j]==Choice.CIRCLE)
                {
                    if(null!=horizontalCheck(Choice.CIRCLE,i,j))
                        return Choice.CIRCLE;
                    if(null!=VerticalCheck(Choice.CIRCLE, i, j))
                            return Choice.CIRCLE;
                    if(null!=mainDiagonalCheck(Choice.CIRCLE,i,j))
                            return Choice.CIRCLE;
                    if(null!=secondDiagonalCheck(Choice.CIRCLE,i,j))
                            return Choice.CIRCLE;                  
                }    
                else if(array[i][j]==Choice.CROSS)
                {
                    if(null!=horizontalCheck(Choice.CROSS,i,j))
                            return Choice.CROSS;
                    if(null!=VerticalCheck(Choice.CROSS, i, j))
                            return Choice.CROSS;
                    if(null!=mainDiagonalCheck(Choice.CROSS,i,j))
                            return Choice.CROSS;
                    if(null!=secondDiagonalCheck(Choice.CROSS,i,j))
                            return Choice.CROSS;                    
                } 
            }
        }
        return null;
    }
    private Choice horizontalCheck(Choice move,int i,int j)
    {
        int countC=0;
        for(int a=i;a<maxSize/tickLine && a<(i+5);a++)
        {
            if(array[a][j]==move)
            {
                countC++;
            }  
            else
            {
                break;
            }
            if(countC==5)
            {                            
               return move;
            }
        }  
        return null;
    }
    
    private Choice VerticalCheck(Choice move,int i,int j)
    {
        int countC=0;
        for(int b=j;b<maxSize/tickLine && b<(j+5);b++)
        {
            if(array[i][b]==move)
            {
                countC++;
            }  
            else
            {
                break;
            }
            if(countC==5)
            {                            
               return move;
            }                        
        }  
        return null;
    }
    private Choice mainDiagonalCheck(Choice move,int i,int j)
    {
        int countC=0;             
        for(int x=0;x<5;x++)
        {
            if((i+x)<maxSize/tickLine && (j+x)<maxSize/tickLine)
            {
                if(array[i+x][j+x]==move)
                {
                    countC++;
                }  
                else
                {
                    break;
                }
                if(countC==5)
                {                            
                    return move;
                }       
            }       
        }
        return null;
    }
    private Choice secondDiagonalCheck(Choice move,int i,int j)
    {
        int countC=0;
        for(int x=0;x<5;x++)
        {
            if((i-x)>=0 && (j+x)<maxSize/tickLine)
            {
                if(array[i-x][j+x]==move)
                {
                    countC++;
                }  
                else
                {
                    break;
                }
                if(countC==5)
                {                            
                    return move;
                }       
            } 
        }
        return null;
    }
    public void newgame()
    {
        for(int i=0;i<columnCount;i++)
            for(int j=0;j<columnCount;j++)
            {
                array[i][j]=null;
            }
        repaint();
    }
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
